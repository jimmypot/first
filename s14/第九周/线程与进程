
Python提供了几个用于多线程编程的模块，包括thread、threading和Queue等。
        (1) thread模块: 允许程序员创建和管理线程，它提供了基本的线程和锁的支持。
        (2) threading模块: 允许程序员创建和管理线程，它提供了更高级别，更强的线程管理的功能。
            threading模块提供的类：Thread, Lock, Rlock, Condition, [Bounded]Semaphore, Event, Timer, local.
        (3) Queue模块: 允许用户创建一个可用于多个线程间共享数据的队列数据结构。
****什么是线程(thread)？
线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。
一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
可以类比：建筑工程项目与工地建设小组，工程项目是一个进程，是一个整体的概念，本身不进行任何的操作，只是一种活动的描述。
而线程是完成一项具体的工作的运作单位，刷一道墙就是一个线程，是一个具体行动的单位。

****什么是进程(process)？
程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：
程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。
一个进程是一个程序执行的实例。

在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。
进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。

****有了进程为什么还要线程？
进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，
既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：

》》进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。
》》进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。

例如，我们在使用qq聊天， qq做为一个独立进程如果同一时间只能干一件事，那他如何实现在同一时刻 即能监听键盘输入、
又能监听其它人给你发的消息、同时还能把别人发的消息显示在屏幕上呢？
你会说，操作系统不是有分时么？分时是指在不同进程间的分时呀，
即操作系统处理一会你的qq任务，又切换到word文档任务上了，每个cpu时间片分给你的qq程序时，你的qq还是只能同时干一件事呀。

再直白一点， 一个操作系统就像是一个工厂，工厂里面有很多个生产车间，不同的车间生产不同的产品，每个车间就相当于一个进程，
且你的工厂又穷，供电不足，同一时间只能给一个车间供电，为了能让所有车间都能同时生产，你的工厂的电工只能给不同的车间分时供电，
但是轮到你的qq车间时，发现只有一个干活的工人，结果生产效率极低，为了解决这个问题，应该怎么办呢？
没错，你肯定想到了，就是多加几个工人，让几个人工人并行工作，这每个工人，就是线程！

****关于守护线程（关于方法：setDaemon; isDaemon）：

Threading模块支持守护线程，它们工作流程如下：守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求，它就在那等着。
如果你设定一个线程为守护线程，就表示你在说这个线程是不重要的，在进程退出时，不用等待这个线程退出，
正如网络编程中服务器线程运行在一个无限循环中，一般不会退出的。如果你的主线程要退出的时候，不用等待那些子线程完成，
那就设定这些线程的daemon属性。
即线程开始（调用thread.start()）之前，调用setDaemon()函数设定线程的daemon标准（thread.setDaemon(True)）就表示这个线程“不重要”。
你可以调用thread.isDaemon()函数来判断其daemon标志的值。新的子线程会继承其父线程的daemon标志，
整个Python会在所有的非守护线程退出后才会结束，即进程中没有非守护线程存在的时候才结束。

****Thread类 ----threading的Thread类是你主要的运行对象。它有很多thread模块里没有的函数。

函数                                            描述

start()                       开始线程的执行
run()                         定义线程的功能的函数（一般会被子类重写）
join(timeout=None)            程序挂起，直到线程结束；如果给了timeout，则最多阻塞timeout秒
getName()                     返回线程的名字
setName(name)                 设置线程的名字
isAlive()                     布尔标志，表示这个线程是否还在运行中
isDaemon()                    返回线程的daemon标志
setDaemon(daemonic)           把线程的daemon标志设为daemonic（一定要在调用start()函数前调用）

用Thread类，可以用多种方法来创建线程。现在介绍三种方法，你可以选择自己喜欢或社和自己程序的方法（通常选择最后一个）：
        (1) 创建一个Thread的实例，传给它一个函数；
        (2) 创建一个Thread的实例，传给它一个可调用的类对象，类似于第一种创建方法；
        (3) 从Thread派生出一个子类，创建一个这个子类的实例。

****线程锁(互斥锁Mutex)
一个进程下可以启动多个线程，多个线程共享父进程的内存空间，也就意味着每个线程可以访问同一份数据，
此时，如果2个线程同时要修改同一份数据，会出现什么状况？访问顺序混乱。
线程（锁）
多线程的优势在于可以同时运行多个任务（至少感觉起来是这样）。但是当线程需要共享数据时，可能存在数据不同步的问题。
考虑这样一种情况：一个列表里所有元素都是0，线程"set"从后向前把所有元素改成1，而线程"print"负责从前往后读取列表并打印。
那么，可能线程"set"开始改的时候，线程"print"便来打印列表了，输出就成了一半0一半1，这就是数据的不同步。
为了避免这种情况，引入了锁的概念。

锁有两种状态——锁定和未锁定。每当一个线程比如"set"要访问共享数据时，必须先获得锁定；如果已经有别的线程比如"print"获得锁定了，
那么就让线程"set"暂停，也就是同步阻塞；等到线程"print"访问完毕，释放锁以后，再让线程"set"继续。
经过这样的处理，打印列表时要么全部输出0，要么全部输出1，不会再出现一半0一半1的尴尬场面。

线程有5种状态：新建（启动）>>就绪（调度）>>运行>>阻塞（当满足阻塞条件时）>>死亡（结束）
阻塞：等待阻塞>>>>同步阻塞,以及其他阻塞
阻塞有三种情况：
》》》同步阻塞是指处于竞争锁定的状态，线程请求锁定时将进入这个状态，一旦成功获得锁定又恢复到运行状态；
》》》等待阻塞是指等待其他线程通知的状态，线程获得条件锁定后，调用“等待”将进入这个状态，一旦其他线程发出通知，
线程将进入同步阻塞状态，再次竞争条件锁定；
》》》其他阻塞是指调用time.sleep()、anotherthread.join()或等待IO时的阻塞，这个状态下线程不会释放已获得的锁定。

当一个线程需要访问共享数据时，该线程会进入锁定池排队等候，请求锁定，此时在锁定池中这些排队的线程处于同步锁定状态，
直到获得锁定。同一时刻只最多有一个线程获得锁定，处于运行状态，当其访问完毕时会释放锁。

条件变量：
对于条件变量，线程会进入等待池中，处于等待状态直到收到通知，然后进入锁定池请求锁定，如果条件不满足，则继续等待。


****RLock(递归锁)
说白了就是在一个大锁中还要再包含子锁
import threading,time

def run1():
    print("grab the first part data")
    lock.acquire()
    global num
    num +=1
    lock.release()
    return num
def run2():
    print("grab the second part data")
    lock.acquire()
    global  num2
    num2+=1
    lock.release()
    return num2
def run3():
    lock.acquire()
    res = run1()
    print('--------between run1 and run2-----')
    res2 = run2()
    lock.release()
    print(res,res2)

if __name__ == '__main__':

    num,num2 = 0,0
    lock = threading.RLock()
    for i in range(10):
        t = threading.Thread(target=run3)
        t.start()

while threading.active_count() != 1:
    print(threading.active_count())
else:
    print('----all threads done---')
    print(num,num2)

****Semaphore(信号量)
互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，
那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去。

Semaphore管理一个内置计数器，每当调用acquire()时-1，调用release() 时+1。计数器不能小于0；
当计数器为0，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。

基于这个特点，Semaphore经常用来同步一些有“访客上限”的对象，比如连接池。

BoundedSemaphore 与Semaphore的唯一区别在于前者将在调用release()时检查计数器的值是否超过了计数器的初始值，
如果超过了将抛出一个异常。

构造方法：
Semaphore(value=1): value是计数器的初始值。
实例方法：
acquire([timeout]): 请求Semaphore。如果计数器为0，将阻塞线程至同步阻塞状态；否则将计数器-1并立即返回。
release(): 释放Semaphore，将计数器+1，如果使用BoundedSemaphore，还将进行释放次数检查。
release()方法不检查线程是否已获得 Semaphore

****Event(线程间通信):
Python提供了Event对象用于线程间通信，它是由线程设置的信号标志，如果信号标志位真，则其他线程等待直到信号接触。
Event对象实现了简单的线程通信机制，它提供了设置信号，清除信号，等待等用于实现线程间的通信。

event = threading.Event() 创建一个event

1 设置信号
event.set()
使用Event的set（）方法可以设置Event对象内部的信号标志为真。Event对象提供了isSet（）方法来判断其内部信号标志的状态。
当使用event对象的set（）方法后，isSet（）方法返回True.
2 清除信号
event.clear()
使用Event对象的clear（）方法可以清除Event对象内部的信号标志，即将其设为假，当使用Event的clear方法后，isSet()方法返回假
3 等待
event.wait()
Event对象wait的方法只有在内部信号为真的时候才会很快的执行并完成返回。当Event对象的内部信号标志位假时，
则wait方法一直等待到其为真时才返回。


****queue队列






