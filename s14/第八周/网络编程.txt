用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。

互联网协议包含上百种协议标准，但最重要的两个协议是TCP和IP协议，所以把互联网的协议简称TCP/IP协议。
通信的时候，双方必须知道对方的标识，好比发邮件必须知道对方的email。互联网上每个计算机的唯一标识就是IP地址，如123.123.123.123。
如果一台计算机同时接入到两个或更多的网络，比如路由器，它就会有两个或多个IP地址，所以IP地址对应的实际上是计算机的网络接口，通常是网卡。

IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。
由于互联网链路复杂，两台计算机之间经常有多条线路，因此，路由器就负责决定如何把一个IP包转发出去。
IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。
IP地址实际上是一个32位整数（称为IPv4），以字符串表示的IP地址如192.168.0.1,实际是把32位整数按8位分组后的数字表示，为了便于阅读。
IPv6地址实际上是一个128位整数，它是目前使用的IPv4的升级版，以字符串表示类似于2001:0db8:85a3:0042:1000:8a2e:0370:7334。

TCP协议则是建立在IP协议之上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。
TCP协议会通过握手建立连接，然后，对每个IP包编号，确保对方按顺序收到，如果包丢掉了，就自动重发。

socket-- 网络编程的抽象概念，打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。
大多数连接都是可靠的TCP连接，创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。

*****python 编写server的步骤：

第一步是创建socket对象。调用socket构造函数。如：
socket = socket.socket( address_family, type )
family参数代表地址家族，可为AF_INET或AF_UNIX。AF_INET家族包括Internet地址，AF_UNIX家族用于同一台机器上的进程间通信。
type参数代表套接字类型，可为SOCK_STREAM(流套接字)和SOCK_DGRAM(数据报套接字)。

第二步是将socket绑定到指定地址。这是通过socket对象的bind方法来实现的：
socket.bind( address )
由AF_INET所创建的套接字，address地址必须是一个双元素元组，格式是(host,port)。host代表主机，port代表端口号。
如果端口号正在使用、主机名不正确或端口已被保留，bind方法将引发socket.error异常。

第三步是使用socket套接字的listen方法接收连接请求。
socket.listen( backlog )
backlog指定最多允许多少个客户连接到服务器。它的值至少为1。收到连接请求后，这些请求需要排队，如果队列满，就拒绝请求。

第四步是服务器套接字通过socket的accept方法等待客户请求一个连接。
conection, address = socket.accept()
调用accept方法时，socket会时入“waiting”状态。客户请求连接时，方法建立连接并返回服务器。
accept方法返回一个含有两个元素的元组(connection,address)。第一个元素connection是新的socket对象，服务器须通过它与客户通信；
第二个元素 address是客户的Internet地址。

第五步是处理阶段，服务器和客户端通过send和recv方法通信(传输数据)。服务器调用send，并采用字符串形式向客户发送信息。
send方法返回已发送的字符个数。服务器使用recv方法从客户接收信息。调用recv 时，服务器必须指定一个整数，
它对应于可通过本次方法调用来接收的最大数据量。recv方法在接收数据时会进入“blocked”状态，最后返回一个字符串，用它表示收到的数据。
如果发送的数据量超过了recv所允许的，数据会被截短。多余的数据将缓冲于接收端。以后调用recv时，
多余的数据会从缓冲区删除(以及自上次调用recv以来，客户可能发送的其它任何数据)。
传输结束，服务器调用socket的close方法关闭连接。

****python编写client的步骤：

>>>创建一个socket以连接服务器：socket = socket.socket( family, type )
>>>使用socket的connect方法连接服务器。对于AF_INET家族,连接格式如下：
socket.connect( (host,port) )
host代表服务器主机名或IP，port代表服务器进程所绑定的端口号。如连接成功，客户就可通过套接字与服务器通信，
如果连接失败，会引发socket.error异常。
>>>处理阶段，客户和服务器将通过send方法和recv方法通信。
>>>传输结束，客户通过调用socket的close方法关闭连接。

http://blog.csdn.net/eastmount/article/details/48909861#t0


***********详解
什么是套接字:
    套接字是一种具有之前所说的“通信端点”概念的计算网络数据结构。相当于电话插口，没它无法通信，这个比喻非常形象。
套接字分两种:
    基于文件型(本机)和基于网络型
》》》第一个套接字家族为AF_UNIX，表示“地址家族：UNIX”。包括Python在内的大多数流行平台上都使用术语“地址家族”及其缩写AF。
由于两个进程都运行在同一台机器上，而且这些套接字是基于文件的，所以它们的底层结构是由文件系统来支持的。
可以理解为同一台电脑上，文件系统确实是不同的进程都能进行访问的。
》》》第二个套接字家族为AF_INET，表示”地址家族：Internet“。还有一种地址家族AF_INET6被用于网际协议IPv6寻址。
Python只支持AF_UNIX、AF_NETLINK和AF_INET家族。网络编程关注AF_INET。
如果把套接字比作电话的查看——即通信的最底层结构，那主机IP与端口就相当于区号和电话号码的一对组合。
一个因特网地址由网络通信必须的主机与端口组成。合法的端口范围是0~65535，其中小于1024端口号为系统保留端口。

面向连接TCP/IP与无连接UDP:
》》》面向连接：通信之前一定要建立一条连接，这种通信方式也被成为”虚电路“或”流套接字“。
面向连接的通信方式提供了顺序的、可靠地、不会重复的数据传输，而且也不会被加上数据边界。这意味着，每发送一份信息，
可能会被拆分成多份，每份都会不多不少地正确到达目的地，然后重新按顺序拼装起来，传给正等待的应用程序。
实现这种连接的主要协议就是传输控制协议TCP。要创建TCP套接字就得创建时指定套接字类型为SOCK_STREAM。
TCP套接字这个类型表示它作为流套接字的特点。由于这些套接字使用网际协议IP来查找网络中的主机，所以这样形成的整个系统，
一般会由这两个协议（TCP和IP）组合描述，即TCP/IP。
》》》无连接：无需建立连接就可以通讯。但此时，数据到达的顺序、可靠性及不重复性就无法保障了。数据报会保留数据边界，
这就表示数据是整个发送的，不会像面向连接的协议先拆分成小块。它就相当于邮政服务一样，邮件和包裹不一定按照发送顺序达到，
有的甚至可能根本到达不到。而且网络中的报文可能会重复发送。
那么这么多缺点，为什么还要使用它呢？由于面向连接套接字要提供一些保证，需要维护虚电路连接，这都是严重的额外负担。
数据报没有这些负担，所有它会更”便宜“，通常能提供更好的性能，更适合某些场合，如现场直播要求的实时数据讲究快等。
实现这种连接的主要协议是用户数据报协议UDP。要创建UDP套接字就得创建时指定套接字类型为SOCK_DGRAM。
这个名字源于datagram（数据报），这些套接字使用网际协议来查找网络主机，整个系统叫UDP/IP。

socket()模块函数:
使用socket模块的socket()函数来创建套接字。语法如下：
    socket(socket_family, socket_type, protocol=0)
其中socket_family不是AF_VNIX（本机）就是AF_INET（Ipv4），socket_type可以是SOCK_STREAM或者SOCK_DGRAM，protocol一般不填，默认值是0。
创建一个TCP/IP套接字的语法如下：
    tcpSock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
同样创建一个UDP/IP套接字的语法如下：
    udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
***由于socket模块中有太多属性，所以使用"from socket import *"语句，把socket模块里面的所有属性都带到命名空间中，大幅缩短代码。
调用如下：
    tcpSock = socket(AF_INET, SOCK_STREAM)

socket对象方法:
下面是最常用的套接字对象方法：
服务器端套接字函数>>>
s.bind() 绑定地址（主机号 端口号对）到套接字
s.listen() 开始TCP监听
s.accept() 被动接受TCP客户端连接，（阻塞式）等待连续的到来

客户端套接字函数>>>
s.connect() 主动初始化TCP服务器连接
s.connect_ex() connect()函数扩展版本，出错时返回出错码而不是跑出异常

公共用途的套接字函数>>>
s.recv() 接受TCP数据
s.send() 发送TCP数据
s.sendall() 完整发送TCP数据
s.recvfrom() 接受UDP数据
s.sendto() 发送UDP数据
s.getpeername() 连接到当前套接字的远端地址（TCP连接）
s.getsockname() 获取当前套接字的地址
s.getsockopt() 返回指定套接字的参数
s.setsockopt() 设置指定套接字的参数
s.close() 关闭套接字

面向模块的套接字函数>>>
s.setblocking() 设置套接字的阻塞与非阻塞模式
s.settimeout() 设置阻塞套接字操作的超时时间
s.gettimeout() 得到阻塞套接字操作的超时时间

面向文件的套接字函数>>>
s.fileno() 套接字的文件描述符
s.makefile() 创建一个与套接字关联的文件对象

提示：在运行网络应用程序时，如果能够使用在不同的电脑上运行服务器和客户端最好不过，它能让你更好理解通信过程，
但更多的是localhost（本地主机）或127.0.0.1.

这里就引入一个重要的概念，“粘包”， 即服务器端你调用时send 2次，但你send调用时，数据其实并没有立刻被发送给客户端，
而是放到系统的socket发送缓冲区里，等缓冲区满或者数据等待超时，数据才会被send到客户端，这样把好几次的小数据拼成一个大数据，
统一发送到客户端了，这么做的目地是为了提高io利用效率，一次性发送总比连发好几次效率高嘛。 但也带来一个问题，就是“粘包”，
即2次或多次的数据粘在了一起统一发送了。
解决方法：服务器端每发送一个数据给客户端，就立刻等待客户端进行回应，即调用 conn.recv(1024),
由于recv在接收不到数据时是阻塞的，这样就会造成服务器端接收不到客户端的响应，就不会执行后面的conn.sendall(命令结果)的指令，
收到客户端响应后，再发送命令结果时，缓冲区就已经被清空了，因为上一次的数据已经被强制发到客户端了。